# -*- coding: utf-8 -*-
"""MCTSProject (Actual)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Wr9UIHBqMUNb2JNlbQmPIbXzkX-Sd2u
"""

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
import statsmodels.api as sm

!pip install yfinance --upgrade --no-cache-dir
import yfinance as yf

import matplotlib.pyplot as plt

smtc = yf.Ticker("SMTC")
slab = yf.Ticker("SLAB")
soxx = yf.Ticker("SOXX")
superPeriod = "15y"
superInterval = "1d"

smdf = pd.DataFrame(smtc.history(start="2007-02-01", end="2022-02-01", interval = superInterval))
sldf = pd.DataFrame(slab.history(start="2007-02-01", end="2022-02-01", interval = superInterval))
sodf = pd.DataFrame(soxx.history(start="2007-02-01", end="2022-02-01", interval = superInterval))

smdf.head()
sldf.head()
sodf.head()

dates_column = range(365)
smdf_close = list(zip(dates_column, smdf["Close"]))
sldf_close = list(zip(dates_column, sldf["Close"]))
sodf_close = list(zip(dates_column, sodf["Close"]))

sm_sl_reg = LinearRegression().fit(smdf_close, sldf_close)
sm_etf_reg = LinearRegression().fit(smdf_close, sodf_close)
sl_etf_reg = LinearRegression().fit(sldf_close, sodf_close)

print(sm_sl_reg.score(smdf_close, sldf_close))
print(sm_etf_reg.score(smdf_close, sodf_close))
print(sl_etf_reg.score(sldf_close, sodf_close))

import os
from google.colab import drive
drive.mount('/content/drive')

# !ls "/content/drive/My Drive/MCap Project"

#/content/drive/Shared with me/MCapProject/FiveFactorData.csv'
#/content/drive/My Drive/MCapProject/FiveFactorData.csv

historical_beta = pd.read_csv('/content/drive/My Drive/MCapProject/FiveFactorData.csv',
                              index_col = 0,
                              parse_dates = [0],
                              skiprows = 3
                              )

len(historical_beta)
historical_beta.head()

def compute_stats(returns):
    mu = returns.mean()
    vol = returns.std()
    SR = mu/vol
    cum_returns = (1 + returns).cumprod()
    rolling_max = cum_returns.cummax()
    days_holding = returns.astype(bool).sum()
    PNL = returns[-1]
    # cum_returns = returns.cumsum()
    # drawdown = (cum_returns - rolling_max) / rolling_max
    # max_drawdown = abs(drawdown.min())
    # return pd.Series({'mean return': mu, 'volatility': vol, 'Sharpe ratio': SR, 'Max Drawdown': max_drawdown})
    return pd.Series({"Total return": PNL, 'mean return': mu, 'volatility': vol, 'Sharpe ratio': SR, "Days held": days_holding})

smdf["Returns"] = smdf["Close"].pct_change()
sldf["Returns"] = sldf["Close"].pct_change()
sodf["Returns"] = sodf["Close"].pct_change()

smdf["Excess Returns"] = smdf["Returns"] - 0.012
sldf["Excess Returns"] = sldf["Returns"] - 0.012
sodf["Excess Returns"] = sodf["Returns"] - 0.012

smdf = smdf.loc["2007-02-13":"2021-12-31", ]
sldf = sldf.loc["2007-02-13":"2021-12-31", ]
sodf = sodf.loc["2007-02-13":"2021-12-31", ]
smdf.head()

ffdf = historical_beta.loc["2007-02-13":, ]
ffdf.tail()

x = sm.add_constant(ffdf[["Mkt-RF", "SMB", "HML", "RMW", "CMA"]])
y = smdf["Excess Returns"]

model_multi = sm.OLS(y, x).fit()
model_multi.summary()

mkt_beta = model_multi.params["Mkt-RF"]
mkt_beta

x = sm.add_constant(ffdf[["Mkt-RF", "SMB", "HML", "RMW", "CMA"]])
y = sldf["Excess Returns"]
model_multi2 = sm.OLS(y, x).fit()
model_multi2.summary()

x = sm.add_constant(ffdf[["Mkt-RF", "SMB", "HML", "RMW", "CMA"]])
y = sodf["Excess Returns"]
model_multi3 = sm.OLS(y, x).fit()
model_multi3.summary()

training_data = ffdf.loc["2007-02-13":"2016-12-31",]
training_data["SMTC"] = smdf["Excess Returns"].loc["2007-02-13":"2016-12-31",]
training_data["SOXX"] = sodf["Excess Returns"].loc["2007-02-13":"2016-12-31",]
training_data["SLAB"] = sldf["Excess Returns"].loc["2007-02-13":"2016-12-31",]
training_data.tail()

x = sm.add_constant(training_data[["Mkt-RF", "SMB", "HML", "RMW", "CMA"]])
smtc_y = training_data["SMTC"]
soxx_y = training_data["SOXX"]
slab_y = training_data["SLAB"]
model_multi1 = sm.OLS(smtc_y, x).fit()
model_multi1.summary()

model_multi2 = sm.OLS(soxx_y, x).fit()
model_multi2.summary()

model_multi3 = sm.OLS(slab_y, x).fit()
model_multi3.summary()

smtc_params = model_multi1.params
soxx_params = model_multi2.params
slab_params = model_multi3.params
slab_params

testing_data = ffdf.loc["2016-12-31":,]
testing_data["SMTC"] = smdf["Excess Returns"].loc["2016-12-31":,]
testing_data["SOXX"] = sodf["Excess Returns"].loc["2016-12-31":,]
testing_data["SLAB"] = sldf["Excess Returns"].loc["2016-12-31":,]
testing_data.tail()

testing_dates = testing_data.index
smtc_expected = pd.Series()
soxx_expected = pd.Series()
slab_expected = pd.Series()
smtc_expected = testing_data["Mkt-RF"] * smtc_params["Mkt-RF"] \
  + testing_data["SMB"] * smtc_params["SMB"] \
  + testing_data["HML"] * smtc_params["HML"] \
  + testing_data["RMW"] * smtc_params["RMW"] \
  + testing_data["CMA"] * smtc_params["CMA"] \
  + smtc_params["const"]
soxx_expected = testing_data["Mkt-RF"] * soxx_params["Mkt-RF"] \
  + testing_data["SMB"] * soxx_params["SMB"] \
  + testing_data["HML"] * soxx_params["HML"] \
  + testing_data["RMW"] * soxx_params["RMW"] \
  + testing_data["CMA"] * soxx_params["CMA"] \
  + soxx_params["const"]
slab_expected = testing_data["Mkt-RF"] * slab_params["Mkt-RF"] \
  + testing_data["SMB"] * slab_params["SMB"] \
  + testing_data["HML"] * slab_params["HML"] \
  + testing_data["RMW"] * slab_params["RMW"] \
  + testing_data["CMA"] * slab_params["CMA"] \
  + slab_params["const"]
slab_expected.head()

expected = pd.DataFrame([smtc_expected, soxx_expected, slab_expected])
expected = expected.transpose()

expected.head()

trading = pd.DataFrame()
trading["SMTC"] = testing_data["SMTC"]
trading["SOXX"] = testing_data["SOXX"]
trading["SLAB"] = testing_data["SLAB"]
trading["SMTC_EV"] = expected[0]
trading["SOXX_EV"] = expected[1]
trading["SLAB_EV"] = expected[2]
trading.head()

residuals = pd.DataFrame()
residuals["SMTC"] = trading["SMTC"] - trading["SMTC_EV"]
residuals["SOXX"] = trading["SOXX"] - trading["SOXX_EV"]
residuals["SLAB"] = trading["SLAB"] - trading["SLAB_EV"]
residuals.head()

# sigma_smtc = residuals["SMTC"].std()

SMTC_stats = compute_stats(residuals["SOXX"])
# residuals["SMTC"]
# SMTC_stats = compute_stats(trading["SMTC_EV"])
SMTC_stats

strat = pd.DataFrame()
strat["SMTC_EVR"] = trading["SMTC_EV"].rolling(6).mean()
strat["SOXX_EVR"] = trading["SOXX_EV"].rolling(6).mean()
strat["SLAB_EVR"] = trading["SLAB_EV"].rolling(6).mean()
strat = strat.loc["2017-01-10":,]

strat

def inPosition(ev1, ev2, param):
  if (ev1 - ev2 > param):
    return 1
  elif (ev2 - ev1 > param):
    return -1
  else:
    return 0

PARAM = 0.002
strat['SMTC_pos'] = strat.apply(lambda row : inPosition(row["SMTC_EVR"], row["SOXX_EVR"], PARAM), axis = 1)
strat["SLAB_pos"] = strat.apply(lambda row : inPosition(row["SLAB_EVR"], row["SOXX_EVR"], PARAM), axis = 1)
strat.astype(bool).sum(axis=0)

strat["SMTC_pos"].sum()
strat

def returnPosition(low, high):

  LOW_PARAM = low
  HIGH_PARAM = high

  decisions1 = [0]
  decisions2 = [0]

  for i in range(1, len(strat)):
    if strat['SMTC_pos'][i-1] == 0:
      decisions1.append(inPosition(strat["SMTC_EVR"][i], strat["SOXX_EVR"][i], HIGH_PARAM))
    else:
      decisions1.append(inPosition(strat["SMTC_EVR"][i], strat["SOXX_EVR"][i], LOW_PARAM))
    if strat['SLAB_pos'][i-1] == 0:
      decisions2.append(inPosition(strat["SLAB_EVR"][i], strat["SOXX_EVR"][i], HIGH_PARAM))
    else:
      decisions2.append(inPosition(strat["SLAB_EVR"][i], strat["SOXX_EVR"][i], LOW_PARAM))

  strat["SMTC_pos"] = pd.Series(decisions1, index = strat.index)
  strat["SLAB_pos"] = pd.Series(decisions2, index = strat.index)

  return strat

# print(decisions1)
# print(sum(decisions1))
# print(pd.Series(decisions1))

strat

strat.head(30)

strat.astype(bool).sum(axis = 0)

def ratio(instr1, instr2, inout):
  # ratio2 contains etf used as base
  #inout expects 1 for long, -1 for short
  # instrs contain asset prices

  ratio = instr2 / instr1

  return (inout * ratio, inout * -1)

# ratio(5, 4, 1)

def populate_positions():
  pos1 = [(0,0)]
  p = 0

  for i in range(1, len(strat)):
    present = strat["SMTC_pos"][i]
    past = strat["SMTC_pos"][i-1]
    if past == 0 and present == 1:
      time = strat.index[i]
      p1 = smdf.loc[time]["Close"]
      p2 = sodf.loc[time]["Close"]
      pos1.append(ratio(p1, p2, 1))
    elif past == 0 and present == -1:
      time = strat.index[i]
      p1 = smdf.loc[time]["Close"]
      p2 = sodf.loc[time]["Close"]
      pos1.append(ratio(p1, p2, -1))
    elif present == 0:
      pos1.append((0,0))
    elif (past == 1 and present == -1) or (past == -1 and present == 1):
      time = strat.index[i]
      p1 = smdf.loc[time]["Close"]
      p2 = sodf.loc[time]["Close"]
      pos1.append(ratio(p1, p2, -past))
    else:
      pos1.append(pos1[-1])

  # strat["pos1"] = pos1

  pos2 = [(0,0)]


  for i in range(1, len(strat)):
    present = strat["SLAB_pos"][i]
    past = strat["SLAB_pos"][i-1]
    if past == 0 and present == 1:
      time = strat.index[i]
      p1 = sldf.loc[time]["Close"]
      p2 = sodf.loc[time]["Close"]
      pos2.append(ratio(p1, p2, 1))
    elif past == 0 and present == -1:
      time = strat.index[i]
      p1 = sldf.loc[time]["Close"]
      p2 = sodf.loc[time]["Close"]
      pos2.append(ratio(p1, p2, -1))
    elif (past == 1 and present == -1) or (past == -1 and present == 1):
      time = strat.index[i]
      p1 = sldf.loc[time]["Close"]
      p2 = sodf.loc[time]["Close"]
      pos2.append(ratio(p1, p2, -past))
    elif present == 0:
      pos2.append((0,0))
    else:
      pos2.append(pos1[-1])

  strat["SMTC_pair"] = pd.Series(pos1, index = strat.index)
  strat["SLAB_pair"] = pd.Series(pos2, index = strat.index)

  return strat

strat

# strat.astype(bool).sum(axis=0)

def compute_results():
  assets = pd.DataFrame()
  assets.index = strat.index

  smtcpos = []
  soxxpos = []
  slabpos = []

  for i in range(len(strat)):
    smtcpos.append(strat["SMTC_pair"][i][0])
    soxxpos.append(strat["SMTC_pair"][i][1] + strat["SLAB_pair"][i][1])
    slabpos.append(strat["SLAB_pair"][i][0])

  assets["SMTCpos"] = smtcpos
  assets["SOXXpos"] = soxxpos
  assets["SLABpos"] = slabpos

  assets["SMTCprice"] = smdf["Close"]
  assets["SOXXprice"] = sodf["Close"]
  assets["SLABprice"] = sldf["Close"]

  assets["Value"] = assets["SMTCpos"] * assets["SMTCprice"] + assets["SOXXpos"] * assets["SOXXprice"] + assets["SLABpos"] * assets["SLABprice"]

  assets["Total PNL"] = assets["Value"].cumsum()
  assets["Daily Return"] = assets["Total PNL"].pct_change()

  return(assets)

def compute_with_params(low, high):
  returnPosition(low, high)
  populate_positions()
  assets = compute_results()
  return compute_stats(assets["Total PNL"])



def max_drawdown(returns):
  rolling_max = returns.cummax()
  drawdown = (returns - rolling_max) / rolling_max
  max_drawdown = drawdown.min()
  return max_drawdown



returnPosition(0.0005, 0.004)
populate_positions()
assets = compute_results()
assets

plt.plot(assets["Daily Return"])